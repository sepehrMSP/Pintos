# تمرین گروهی ۱.۱ - مستند طراحی

گروه 7

-----

 > نام و آدرس پست الکترونیکی اعضای گروه را در این قسمت بنویسید.

محمدسپهر پورقناد sepehrpourghannad@yahoo.com

فرزام زهدی نسب farzamzohdi@gmail.com

سید محمدصادق کشاورزی mohammadsadeghkeshavarzi@yahoo.com

مصطفی اوجاقی  m.ojaghy@gmail.com

مقدمات

----------

> اگر نکات اضافه‌ای در مورد تمرین یا برای دستیاران آموزشی دارید در این قسمت  بنویسید.

> لطفا در این قسمت تمامی منابعی (غیر از مستندات Pintos، اسلاید‌ها و دیگر منابع درس) را که برای تمرین از آن‌ها استفاده کرده‌اید در این قسمت بنویسید.

پاس‌دادن آرگومان

============

داده‌ساختار‌ها

----------------

> در این قسمت تعریف هر یک از `struct` ها، اعضای `struct` ها، متغیرهای سراسری یا ایستا، `typedef` ها یا `enum` هایی که ایجاد کرده‌اید یا تغییر داده‌اید را بنویسید و دلیل هر کدام را در حداکثر ۲۵ کلمه توضیح دهید.

نیازی نیست!

الگوریتم‌ها

------------

> به‌طور خلاصه توضیح دهید چگونه آرگومان‌ها را پردازش کرده‌اید؟ چگونه اعضای `argv[]` را به ترتیب درست در پشته قرار داده‌اید؟ و چگونه از سرریز پشته جلوگیری کرده‌اید؟

ابتدا با استفاده از تابع strtok_r تعداد آرگومان‌ها و رشته‌ی آنها را مشخص می‌کنیم. سپس مقادیر آنها و سپس اشاره‌گر به آنها را در پشته بترتیب راست به چپ (در رشته ورودی) پوش می‌کنیم (ابتدا همه مقادیر، سپس اشاره‌گرها) (توجه کنید که چون امکان استفاده از malloc را نداریم این مقادیر را در استک ذخیره می‌کنیم). سپس argv و argc  را در پشته ذخیره می‌کنیم. در تابع `load` در فایل `process.c` در قسمت `filesys_open (file_name);` 	به جای متغیر `file_name`  نام فایل اجرایی که با استفاده از تابع `strtok_r` بدست آوردیم استفاده می‌کنیم.
برای جلوگیری از سرریز پشته با توجه به تعداد نشانه‌هایی که با تابع `strtok_r`  بدست آوردیم می‌بایست اشاره‌گر پشته را پایین بیاوریم تا زمانی که مقادیر آرگومان‌ها و اشاره‌گر ها را در پشته پوش می‌کنیم وارد فضای کرنل نشویم (از `PHYS_BASE`  بالاتر).

برای جلوگیری از سرریز پشته با توجه به تعداد نشانه‌هایی که با تابع `strtok_r`  بدست آوردیم می‌بایست اشاره‌گر پشته را پایین بیاوریم تا زمانی که مقادیر آرگومان‌ها و اشاره‌گر ها را در پشته پوش می‌کنیم وارد فضای کرنل نشویم (از `PHYS_BASE`  بالاتر).

منطق طراحی

-----------------

> چرا Pintos به‌جای تابع‌ `strtok()` تابع‌ `strtok_r()` را پیاده‌سازی کرده‌است؟

با توجه به اینکه ریسه‌ها و همگام‌سازی بین آنها در این سیستم‌عامل به درستی انجام نمی‌شود، به جهت جلوگیری از شرایط سبقت، از تابع `strtok_r` استفاده می‌شود. درواقع پیاده‌سازی `strtok` به صورت زیر است:

```

char *strtok(char *str, const char *delim) {

    static char *save;

    return strtok_r(str, delim, &save);

}

```


که متغیر سراسری می‌تواند مشکل ایجاد کند.

> در Pintos عمل جدا کردن نام فایل از آرگومان‌ها، در داخل کرنل انجام می‌شود. در سیستم عامل‌های برپایه‌ی Unix، این عمل توسط shell انجام می‌شود. حداقل دو مورد از برتری‌های رویکرد Unix را توضیح دهید.

برتری اول و ساده‌تر و مهم‌تر این است که وقتی کار جدا کردن آرگومان‌ها در shell انجام شود، در صورت رخ دادن خطا، برای کرنل مشکلی پیش نمی‌آید و فقط پروسهٔ کاربر به مشکل می‌خورد، بخصوص که کار با رشته‌ها نیازمند احتیاط است. از طرفی، وقتی جدا کردن آرگومان‌ها در پروسهٔ کاربر صورت بگیرد، از حافظهٔ خود پروسه استفاده می‌شود و پروسه در مورد حافظهٔ خودش آگاهی بیشتری دارد، اما اگر این کار در کرنل انجام شود، کرنل باید جایی در حافظهٔ کاربر را برای ذخیره کردن رشته در نظر بگیرد، و با توجه به اینکه کرنل اطلاع دقیقی از چینش و نحوهٔ استفادهٔ پروسه از حافظهٔ خود را ندارد، این کار کمی سخت است.

فراخوانی‌های سیستمی

================

داده‌ساختار‌ها

----------------

> در این قسمت تعریف هر یک از `struct` ها، اعضای `struct` ها، متغیرهای سراسری یا ایستا، `typedef` ها یا `enum` هایی که ایجاد کرده‌اید یا تغییر داده‌اید را بنویسید و دلیل هر کدام را در حداکثر ۲۵ کلمه توضیح دهید.

```

struct thread {

    ...

    struct list children;
    struct semaphore sema;
    struct file* bin_file;
    int exit_code;

    ...

}

```


تغییرات زیر به داده‌ساختار `thread` اضافه می‌شوند.

`children` : لیستی از ریسه‌های فرزند را در خود نگه می‌دارد.

`sema`: سمافور مربوط به ریسه کنونی است که برای همگام‌سازی استفاده می‌شود.

`bin_file`: پرونده اجرایی ریسه موجود را نگه‌داری می‌کند.
`exit_code`: وضعیت  بارگذاری فایل اجرایی ریسه مربوطه را نشان می‌دهد. درصورت خطا -۱ می‌شود.

```

struct thread_file {

    struct list_elem elem;

    int fd;

    struct file* file;

}

```


این داده‌ساختار وضعیت کنونی پرونده‌های موجود را نگه‌داری می‌کند.

`elem` : برای اینکه بتوان به عنوان یک لیست به هم پیوسته از آن استفاده کرد.

`fd`: شرح‌دهنده پرونده.

`file`: اشاره‌گر به داد‌ه‌ساختار `file`  است که در آن اطلاعات مختلف فایل را نگه‌داری می‌کند (توجه کنید که `fd`  در آن ذکر نشده برای همین ما آن را در داده ساختار خود لحاظ کردیم).

`struct lock file_lock;`

  این متغیر را همانطور که در مستند آمده است برای برقراری همگام‌سازی بین اعمال مربوط به پرونده‌ها در نظر گرفتیم.

> توضیح دهید که توصیف‌کننده‌های فایل چگونه به فایل‌های باز مربوط می‌شوند. آیا این توصیف‌کننده‌ها در کل سیستم‌عامل به‌طور یکتا مشخص می‌شوند یا فقط برای هر پردازه یکتا هستند؟

در داده‌ساختاری که در بالا آوردیم یک قسمت از آن مربوط به توصیف‌کننده پرونده بود و از این طریق ما توصیف‌کننده‌های پرونده‌ها را در کد ذخیره‌ می‌کنیم. چون خودمان تعیین می‌کنیم که در خروجی توابع مربوط به پرونده‌ها چه توصیف‌کننده‌ای برمی‌گردانیم، توصیف‌کننده‌ها ار در سطح سیستم‌عامل یکتا می‌گیریم.

الگوریتم‌ها

------------

> توضیح دهید خواندن و نوشتن داده‌های کاربر از داخل هسته، در کد شما چگونه انجام شده است.

> فرض کنید یک فراخوانی سیستمی باعث شود یک صفحه‌ی کامل (۴۰۹۶ بایت) از فضای کاربر در فضای هسته کپی شود. بیشترین و کمترین تعداد بررسی‌‌های جدول صفحات (page table) چقدر است؟ (تعداد دفعاتی که `pagedir_get_page()` صدا زده می‌شود.) در‌ یک فراخوانی سیستمی که فقط ۲ بایت کپی می‌شود چطور؟ آیا این عددها می‌توانند بهبود یابند؟ چقدر؟

> پیاده‌سازی فراخوانی سیستمی `wait` را توضیح دهید و بگویید چگونه با پایان یافتن پردازه در ارتباط است.

در ابتدا که یک ریسه را شروع می‌کنیم، سمافور مربوط به آن ریسه را با مقدار صفر ایجاد می‌کنیم. سپس به ازای هر ریسه‌ی دیگری که روی این ریسه `wait` کند،‌ `sema_down` را روی آن صدا می‌زنیم. هنگامی که ریسه منتظَر به اتمام رسید، `sema_up` را صدا‌ می‌زند و تمامی ریسه‌های منتظر از حالت انتظار خارج می‌شوند (توجه کنید که برای هر ریسه در هر زمان حداکثر یک ریسه دیگر (پدر آن) می‌تواند روی آن انتظار بکشد).

> هر دستیابی هسته به حافظه‌ی برنامه‌ی کاربر، که آدرس آن را کاربر مشخص کرده است، ممکن است به دلیل مقدار نامعتبر اشاره‌گر منجر به شکست شود. در این صورت باید پردازه‌ی کاربر خاتمه داده شود. فراخوانی های سیستمی پر از چنین دستیابی‌هایی هستند. برای مثال فراخوانی سیستمی `write‍` نیاز دارد ابتدا شماره‌ی فراخوانی سیستمی را از پشته‌ی کاربر بخواند، سپس باید سه آرگومان ورودی و بعد از آن مقدار دلخواهی از حافظه کاربر را (که آرگومان ها به آن اشاره می کنند) بخواند. هر یک از این دسترسی ها به حافظه ممکن است با شکست مواجه شود. بدین ترتیب با یک مسئله‌ی طراحی و رسیدگی به خطا (error handling) مواجهیم. بهترین روشی که به ذهن شما می‌رسد تا از گم‌شدن مفهوم اصلی کد در بین شروط رسیدگی به خطا جلوگیری کند چیست؟ همچنین چگونه بعد از تشخیص خطا، از آزاد شدن تمامی منابع موقتی‌ای که تخصیص داده‌اید (قفل‌ها، بافر‌ها و...) مطمئن می‌شوید؟ در تعداد کمی پاراگراف، استراتژی خود را برای مدیریت این مسائل با ذکر مثال بیان کنید.

با توجه به اینکه در شرایط کنونی حافظه‌ای را مشخص نکرده‌ایم، تنها در مواقعی که اشاره‌گر نامعتبر داشته باشیم، کافی است که تابع `thread_exit()` را صدا بزنیم و صفحه مربوط به ریسه آزاد می‌شود.

برای رسیدگی به خطاهای تابع و به طور کلی اطمینان از صحت کارکرد توابع، در ابتدای هر تابع شروطی که هر کدام از آرگومان‌‌ها می‌بایست رعایت کنند را با استفاده از تابعی بنام `check_err` بررسی می‌کنیم. کارکرد این تابع همانند `ASSERT` است با این تفاوت که در صورت تشخیص خطا به‌جای `PANIC` ، کد خروج مناسب را برمی‌گرداند. بدیهی است که این کار بخش جدایی از مفهوم اصلی کد است.

`check_err(arg, char * type, condition);`

در حالت کنونی مثالی برای گرفتن حافظه در توابع سیستمی نداریم، اما در صورت نیاز با استفاده از داده‌ساختار زیر متغیر‌هایی که در حافظه گرفته‌ایم را نگه داریم می‌کنیم تا در صورت وقوع خطا با حرکت روی این لیست تمامی متغیر‌ها را آزاد می‌کنیم.

```

struct allocated {

    struct list_elem elem;

    void *ptr;

}

```


همگام‌سازی

---------------

> فراخوانی سیستمی `exec` نباید قبل از پایان بارگذاری فایل اجرایی برگردد، چون در صورتی که بارگذاری فایل اجرایی با خطا مواجه شود باید `-۱` برگرداند. کد شما چگونه از این موضوع اطمینان حاصل می‌کند؟ چگونه وضعیت موفقیت یا شکست در اجرا به ریسه‌ای که `exec` را فراخوانی کرده اطلاع داده می‌شود؟
تابع `exec` پس از اجرا شدن وارد `process_execute` را صدا می‌زند که در آنجا ریسه جدید ساخته می‌شود و سپس تابع `process_start` صدا زده می‌شود. در این تابع `load` وظیفه این را دارد که فایل اجرایی را بخواند. حال کافی است که در صورت بروز خطا در داده‌ساختار ریسه مربوطه متغیر `exit_code` را برابر -۱ قرار دهد. در این صورت ریسه پدر به راحتی می‌تواند وضعیت بارگذاری فایل اجرایی ریسه فرزند را براحتی متوجه شود (توجه کنید که ریسه پدر در داده‌ساختار خود (در طراحی ما) به ریسه‌های فرزند دسترسی دارد).


> پردازه‌ی والد P و پردازه‌ی فرزند C را درنظر بگیرید. هنگامی که P فراخوانی `wait(C)` را اجرا می‌کند و C  هنوز خارج نشده است، توضیح دهید که چگونه همگام‌سازی مناسب را برای جلوگیری از ایجاد شرایط مسابقه (race condition) پیاده‌سازی کرده‌اید. وقتی که C از قبل خارج شده باشد چطور؟ در هر حالت چگونه از آزاد شدن تمامی منابع اطمینان حاصل می‌کنید؟ اگر P بدون منتظر ماندن، قبل از C خارج شود چطور؟ اگر بدون منتظر ماندن بعد از C خارج شود چطور؟ آیا حالت‌های خاصی وجود دارد؟
در قسمت الگوریتم نحوه‌ی کارکرد تابع انتظار توضیح داده شده است و برای جلوگیری از شرایط مسابقه از سمافور استفاده کرده‌ایم که جززیات آن را در بالا توضیح داده‌ایم.
مشکلی پیش نمی‌آید چون در صورتی که فرزند خارج شده باشد، مقدار سمافور ۱ خواهد بود و هنگامی پدر روی آن انتظار می‌کشد تابع `sema_down` صدا زده می‌شود و مقدار سمافور را صفر کرده و بازمی‌گردد.
اگر یک منبع به صورت داخلی برای یک ریسه باشد پس از پایان ریسه منابع آزاد می‌شوند. برای منابع مشترک نیز از قفل برای جلوگیری از شرایط مسابقه استفاده می‌کنیم. بدیهی است که آخرین ریسه‌ای که قفل را در اختیار دارد منبع مربوطه را آزاد می‌کند.
چنین حالتی در طراحی ما ممکن نیست، چراکه هر ریسه پدر می‌بایست تا اتمام تمامی فرزند‌های خود منتظر بماند.
این حالت مشکلی بوجود نمی‌آید. گویی فرزند از ابتدا وجود نداشته است (در واقع در این حالت هم پدر در انتهای اجرای خود روی فرزند انتظار می‌کشد ولی چون کار فرزند تمام شده است این انتظار بلافاصله به اتمام می‌رسد.)
با توجه به اینکه در طراحی اولویت با ریسه فرزند است، تمامی حالات گفته شده در بالا بررسی شده‌اند.

منطق طراحی

-----------------
> به چه دلیل روش دسترسی به حافظه سطح کاربر از داخل هسته را این‌گونه پیاده‌سازی کرده‌اید؟



> طراحی شما برای توصیف‌کننده‌های فایل چه نقاط قوت و ضعفی دارد؟

> در حالت پیش‌فرض نگاشت `tid` به `pid` یک نگاشت همانی است. اگر این را تغییر داده‌اید، روی‌کرد شما چه نقاط قوتی دارد؟

سوالات افزون بر طراحی

===========

> تستی را که هنگام اجرای فراخوانی سیستمی از یک اشاره‌گر پشته‌ی(esp) نامعتبر استفاده کرده است بیابید. پاسخ شما باید دقیق بوده و نام تست و چگونگی کارکرد آن را شامل شود.
`Sc-bad-sp.c`
این برنامه ابتدا مقدار نامعتبری را در %esp قرار می‌دهد و سپس فراخوانی سیستمی را به صورت کد اسمبلی صدا می‌کند. برنامه باید `exit(-1)` انجام دهد.

> تستی را که هنگام اجرای فراخوانی سیستمی از یک اشاره‌گر پشته‌ی معتبر استفاده کرده ولی اشاره‌گر پشته آنقدر به مرز صفحه نزدیک است که برخی از آرگومان‌های فراخوانی سیستمی در جای نامعتبر مموری قرار گرفته اند مشخص کنید. پاسخ شما باید دقیق بوده و نام تست و چگونگی کارکرد آن را شامل شود.یک قسمت از خواسته‌های تمرین را که توسط مجموعه تست موجود تست نشده‌است، نام ببرید. سپس مشخص کنید تستی که این خواسته را پوشش بدهد چگونه باید باشد.
`Sc-bad-arg.c`
این برنامه عدد `SYS_EXIT` را در بالای پشته قرار می‌دهد و سپس فراخوانی سیستمی در حالی که اشاره‌گر پشته به آدرس آن اشاره دارد صدا می‌کند. برنامه باید `exit(-1)` انجام دهد چرا که آرگومان فراخوانی سیستمی بالای فضای آدرسی کاربر قرار دارد.
صحت کارکرد در زمانی که یک ریسه به هنگامی که قفلی را در اختیار دارد به علت صدا زدن یک فراخوانی سیستمی از بین برود و قفل را رها کند در تست‌ها نیامده است. برای مثال دو ریسه داشته باشیم که اولی قفلی را گرفته است و سپس ریسه دیگر هم برای گرفتن همان قفل تلاش کند و موفق نشود آن را در اختیار بگیرد پس مجبور به انتظار شود. سپس ریسه اول یک فراخوانی سیستمی نامعتبر انجام دهد و از بین برود. در این مثال اگر ریسه اول قفل را رها نکند ریسه دوم هیچگاه از حالت انتظار در نمی‌آید ولی اگر به درستی قفل رها‌سازی شود ریسه دوم قفل را در اختیار می‌گیرد و از حالت انتظار خارج می‌شود.

سوالات نظرخواهی

==============

پاسخ به این سوالات اختیاری است، ولی پاسخ به آن‌ها می‌تواند به ما در بهبود درس در ترم‌های آینده کمک کند. هر چه در ذهن خود دارید بگویید. این سوالات برای دریافت افکار شما هستند. هم‌چنین می‌توانید پاسخ خود را به صورت ناشناس در انتهای ترم ارائه دهید.

> به نظر شما، این تمرین یا هر یک از سه بخش آن، آسان یا سخت بودند؟ آیا وقت خیلی کم یا وقت خیلی زیادی گرفتند؟

> آیا شما بخشی را در تمرین یافتید که دید عمیق‌تری نسبت به طراحی سیستم عامل به شما بدهد؟

> آیا مسئله یا راهنمایی خاصی وجود دارد که بخواهید برای حل مسائل تمرین به دانشجویان ترم‌های آینده بگویید؟

> آیا توصیه‌ای برای دستیاران آموزشی دارید که چگونه دانشجویان را در ترم‌های آینده یا در ادامه‌ی ترم بهتر یاری کنند؟

> اگر نظر یا بازخورد دیگری دارید در این قسمت بنویسید.
