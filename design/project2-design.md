# سیستم‌های عامل - تمرین گروهی دوم

## مشخصات گروه

>> نام، نام خانوادگی و ایمیل خود را در ادامه وارد کنید.

محمدسپهر پورقناد sepehrpourghannad@yahoo.com

سیدمحمدصادق کشاورزی <email@domain.example>

فرزام زهدی نسب <email@domain.example>

مصطفی اوجاقی <email@domain.example>

## مقدمه

>> اگر نکته‌ای درباره فایل‌های سابمیت شده یا برای TAها دارید، لطفا اینجا بیان کنید.

>> اگر از هر منبع برخط یا غیر برخطی به غیر از مستندات Pintos، متن درس، اسلایدهای درس یا نکات گفته شده در کلاس در تمرین گروهی استفاده کرده‌اید، لطفا اینجا آن(ها) را ذکر کنید.

## ساعت زنگ‌دار

### داده ساختارها

>> پرسش اول: تعریف `struct`های جدید، `struct`های تغییر داده شده، متغیرهای گلوبال یا استاتیک، `typedef`ها یا `enumeration`ها را در اینجا آورده و برای هریک در 25 کلمه یا کمتر توضیح بنویسید.
```
struct thread {
...
int wake_up_time;
...
}
```

متغیر `wake_up_time` را به داده‌ساختار ریسه اضافه می‌کنیم. این متغیر حداقل زمان برای بیدار شدن ریسه را مشخص می‌کند.

```
struct list sleepers;
struct lock sleepers_lock;
```

`sleeper` یک لیست از ریسه‌هایی است که در خواب می‌باشند. `sleepers_lock` هم یک قفل است که برای اضافه کردن یا حذف کردن ریسه‌ها از لیست مذکور استفاده می‌شود تا شرایط مسابقه پیش نیاید.

### الگوریتم

>> پرسش دوم: به اختصار آن‌چه هنگام صدا زدن تابع `timer_sleep()` رخ می‌دهد و همچنین اثر `timer interrupt handler` را توضیح دهید.
در این تابع دیگر نیازی به استفاده از حلقه‌ی مشغول برای پیاده‌سازی خوابیدن ریسه‌ها نیست. درواقع با ورود به این تابع ابتدا حداقل زمانی که ریسه قرار است از خواب بیدار شود محاسبه می‌شود. سپس ریسه مربوطه را در لیست ریسه‌های خواب قرار می‌دهد.توجه کنید که ریسه‌ها را باید در حالت `block` قرار داد و سپس آنها را در لیست قرار داد.
همچنین در تابع `timer_interrupt` تابع `thread_tick` صدا زده می‌شود که در آنجا می‌بایست از روی لیست ریسه‌های در خواب بررسی کرد که کدامیک از آنها شرایط بیدار شدن از خواب را دارد.

>> پرسش سوم: مراحلی که برای کوتاه کردن زمان صرف‌شده در `timer interrupt handler` صرف می‌شود را نام ببرید.
در این تابع می‌بایست اولین ریسه‌ای که آماده بیدار شدن است را انتخاب کنیم. پس نیاز داریم که ریسه‌ای با کمترین مقدار `wake_up_time` را بیدار کنیم. بدین منظور دو راهکار پیشنهاد می‌شود. اول اینکه روی لیست ریسه‌های در خواب حرکت کنیم و از بین آنها ریسه‌ مذکور را پیدا کنیم که این روش پیچیدگی زمانی خطی دارد. روش دیگر این است که از لیست مرتب شده استفاد کنیم تا همیشه ریسه با زودترین زمان بیدار شدن از خواب در ابتدای لیست قرار بگیرد. پیچیدگی زمانی این کار از مرتبه ۰ خواهد بود هرچند پیچیدگی پیاده‌سازی لیست مرتب از لیست معمولی بیشتر است.
### همگام‌سازی

>> پرسش چهارم: هنگامی که چند ریسه به طور همزمان `timer_sleep()` را صدا می‌زنند، چگونه از `race condition` جلوگیری می‌شود؟
با توجه به قفلی که به صورت جهانی تعریف کردیم، هر ریسه برای اینکه بتواند در لیست ریسه‌های خواب عملیاتی انجام بدهد، چه حذف چه اضافه، می‌بایست این قفل را در اختیار بگیرد. در نتیجه در هر لحظه حداکثر یک ریسه در حال عملیات روی‌ این لیست است.
>> پرسش پنجم: هنگام صدا زدن `timer_sleep()` اگر یک وقفه ایجاد شود چگونه از `race condition` جلوگیری می‌شود؟
برای اینکه حین عملیات روی لیست ریسه‌های در خواب مشکلی بوجود نیاید (مثلا از طرف ریسه‌ای دیگر در وقفه بیاید و باعث شود مقدار `ticks` دیگر معتبر نباشد و زمان بیدار شدن ریسه مربوطه اشتباه ثبت شود)، در ابتدای این تابع وقفه‌ها را غیر فعال می‌کنیم و پس از اینکه‌ ریسه مربوطه در لیست ریسه‌های در حال خواب قرار گرفت آن وقفه را فعال می‌کنیم.

### منطق

>> پرسش ششم: چرا این طراحی را استفاده کردید؟ برتری طراحی فعلی خود را بر طراحی‌های دیگری که مدنظر داشته‌اید بیان کنید.
طراحی دیگری مد نظر نداشتیم، اما از مزایای این طراحی می‌توان به ساده بودن آن اشاره کرد که باعث می‌شود پیاده‌سازی آن راحتر باشد. همچنین  پیچیدگی زمانی نیز حداکثر خطی خواهد بود که آن را هم می‌توان با پیاده‌سازی لیست مرتب کاهش داد.  

## زمان‌بند اولویت‌دار

### داده ساختارها

>> پرسش اول: تعریف `struct`های جدید، `struct`های تغییر داده شده، متغیرهای گلوبال یا استاتیک، `typedef`ها یا `enumeration`ها را در اینجا آورده و برای هریک در ۲۵ کلمه یا کمتر توضیح بنویسید.
```
struct thread {
...
int initial_priority;
int effective_priority;
struct list owned_locks;
struct lock * waited_lock;
...
}
```

برای هر ریسه یک متغیر نگه می‌داریم که اولویتی که ریسه با ‌آن ساخته می‌شود را نگه داری می‌کند بنام `initial_thread`. متغیر `effective_thread` برای این استفاده می‌شود که بدانیم در لحظه اولیت یک ریسه چیست. `owned_locks` نیز لیست قفل‌هایی است که در اختیار ریسه قرار دارد.  `waited_lock` هم اشاره‌گر به قفلی است که ریسه هم اکنون منتظر آن است (احتمالا نال).
```
struct semaphore {
...
int priority;
struct list_elem elem;
struct thread * owner;
struct list waiters;
...
}
```

`priority` تعیین می‌کند که اولویت قفل فعلی چیست و توسط کسی آن را در اختیار دارد تعیین می‌شود. `waiters` نیز لیست ریسه‌هایی هستند که در انتظار آزاد شدن قفل هستند. `owner` نیز ریسه‌ای را اشاره می‌کند که قفل را در اختیار دارد.
>> پرسش دوم: داده‌ساختارهایی که برای اجرای `priority donation` استفاده شده‌است را توضیح دهید. (می‌توانید تصویر نیز قرار دهید)
در قسمت بالا توضح داده شده است.

### الگوریتم

>> پرسش سوم: چگونه مطمئن می‌شوید که ریسه با بیشترین اولویت که منتظر یک قفل، سمافور یا `condition variable` است زودتر از همه بیدار می‌شود؟
در ابتدا توجه کنید که پیاده‌سازی قفل و متغیر‌های شرطی، بوسیله سمافور انجام‌ می‌شود. بیدار کردن نیز زمانی انجام می‌شود که کار یک ریسه تمام شده باشد و بخواهد سمافور مربوطه را `up` کند.  پس کافی است که به هنگام رفع انسداد، ریسه با اولویت موثر بیشینه را از لیست منتظران خارج کنیم و آن را بیدار کنیم.

>> پرسش چهارم: مراحلی که هنگام صدازدن `lock_acquire()` منجر به `priority donation` می‌شوند را نام ببرید. دونیشن‌های تو در تو چگونه مدیریت می‌شوند؟
ابتدا بررسی می‌شود که آیا قفل در اختیار ریسه دیگری است یا خیر (با بررسی نال بودن یا نبودن اشاره‌گر `owner`). اگر قفل صاحبی نداشت پس ریسه فعلی را به عنوان صاحب آن منسوب می‌کنیم و اولیت قفل را برابر اولویت موثر ریسه مربوطه قرار می‌دهیم و قفل را در لیست قفل‌هایی که در اختیار ریسه هست اضافه می‌کنیم.
در غیر این صورت ریسه را در لیست منتظران قفل مربوطه قرار می‌دهیم. اگر ریسه مربوطه اولویتش از اولویت قفل بیشتر بود (نیار به اهدای اولویت) در این صورت اولویت قفل و اولویت موثر ریسه دارنده آن را برابر اولویت ریسه جدید قرار می‌دهیم و این کار را به صورت بازگشتی برای `owner`ها انجام می‌دهیم و مقادیر اولویت موثر آنها را بروز رسانی می‌کنیم. در نهایت `thread_yield()` را صدا می‌زنیم تا دوباره ریسه‌ها برنامه‌ریزی شوند. در این شرایط چون اولویت ریسه دارنده بیشینیه شده به عنوان ریسه بعدی برای اجرا انتخاب می‌شود.

>> پرسش پنجم: مراحلی که هنگام صدا زدن `lock_release()` روی یک قفل که یک ریسه با اولویت بالا منتظر آن است، رخ می‌دهد را نام ببرید.
برای ریسه دارنده قفل، ابتدا قفل را از لیست قفل‌های در اختیار ریسه حذف می‌کنیم. سپس اولویت موثر ریسه را برابر بیشینه‌ی اولویت لیست مابقی قفل‌هایی که در اختیار دارد و `initial_priority` قرار می‌دهیم.
سپس دارنده‌ی قفل را برابر ریسه‌ای با بیشنیه اولویت موثر از بین منتظران قرار می‌دهیم و آن را از لیست منتظران حذف می‌کنیم. اولیت قفل را بروزرسانی می‌کنیم.

### همگام‌سازی

>> پرسش ششم: یک شرایط احتمالی برای رخداد `race condition` در `thread_set_priority` را بیان کنید و توضیح دهید که چگونه پیاده‌سازی شما از رخداد آن جلوگیری می‌کند. آیا می‌توانید با استفاده از یک قفل از رخداد آن جلوگیری کنید؟

با توجه به اینکه ما به مقدار اولیه اولیوت تعیین شده برای ریسه دست نمی‌زنیم و تنها بر اساس مقدار اولویت موثر زمانبندی انجام می‌دهیم این حالت پیش‌نمی‌آید.

در حالتی که آزاد کردن قفل رخ ‌می‌دهد تغییرات مربوط به اولویت‌های موثر ریسه‌ها درون تابع ‍`sema_up` انجام خواهد شد که با توجه ‌به اینکه درون آن وقفه‌ها غیرفعال هستند شرایط مسابقه بوجود نمی‌آید. در حالت گرفتن قفل نیز که می‌بایست `sema_down` زد به دلیل مشابه قبل شرایط مسابقه بوجود نمی‌آید.

### منطق

>> پرسش هفتم: چرا این طراحی را استفاده کردید؟ برتری طراحی فعلی خود را بر طراحی‌های دیگری که مدنظر داشته‌اید بیان کنید.
طراحی دیگری در ذهنمان نبود. مزیت این طراحی این است که تمامی عملیات‌ها، به خصوص بروزرسانی اولویت‌های موثر، در زمان خطی انجام می‌شود. همچنین توجه کنید که هنگام اضافه شدن یک ریسه جدید به لیست منتظران لازم نیست تا در O(n) آپدیت شود چون مقدار بیشینه را از قبل نگه داشته‌ایم.
توجه کنید که حتی در صورت استفاده از صف اولویت‌دار، هر ند که موقع بدست آوردن مقدار بیشینه سریع‌تر خواهیم بود اما در هنگام اضافه کردن ریسه به لیست باید عملیات در پیچیدگی زمانی O(n) انجام دهیم که در صورتی که تعداد ریسه‌ها زیاد باشند بسیار زمان‌بر خواهد بود.

## سوالات افزون بر طراحی

>> پرسش هشتم: در کلاس، سه صفت مهم ریسه‌ها که سیستم عامل هنگامی که ریسه درحال اجرا نیست را ذخیره می‌کند، بررسی کردیم:‍‍ `program counter` ، ‍‍‍`stack pointer` و `registers`. بررسی کنید که این سه کجا و چگونه در `Pintos` ذخیره می‌شوند؟ مطالعه ‍`switch.S` و تابع ‍`schedule` در فایل `thread.c` می‌تواند مفید باشد.
    movl %esp, (%eax,%edx,1)
    در این خط اشاره‌گر پشته ریسه فعلی را ذخیره می‌کنیم.
    سپس در خطوط بعدی اشاره گر ریسه جدید را تنظیم ‌می‌کنیم.
    movl SWITCH_CUR(%esp), %eax
    movl %esp, (%eax,%edx,1)


>> پرسش نهم: وقتی یک ریسه‌ی هسته در ‍`Pintos` تابع `thread_exit` را صدا می‌زند، کجا و به چه ترتیبی صفحه شامل پشته و `TCB` یا `struct thread` آزاد می‌شود؟ چرا این حافظه را نمی‌توانیم به کمک صدازدن تابع ‍`palloc_free_page` داخل تابع ‍`thread_exit` آزاد کنیم؟

در تابع `schedule`  پس از اینکه عملیات تعویض ریسه را انجام داد (احتمالا هیچ) در انتها تابع `thread_schedule_tail` را صدا می‌زند و در صورتی که ریسه قبلی `IS_DYING` بود صفحه‌ آن را آزاد می‌کند.
توجه کنید که در `thread_exit` همچنان در ریسه فعلی هستیم و عملیات `schdule` و `switch_thread` انجام نشده است. به همین خاطر از بین بردن و آزاد کردن صحفه ریسه کنونی کار درستی نیست.

>> پرسش دهم: زمانی که تابع ‍`thread_tick` توسط `timer interrupt handler` صدا زده می‌شود، در کدام پشته اجرا می‌شود؟
با توجه به مستند پینتوس در پشته کرنل اجرا می‌شود.

>> پرسش یازدهم: یک پیاده‌سازی کاملا کاربردی و درست این پروژه را در نظر بگیرید که فقط یک مشکل درون تابع ‍`sema_up()` دارد. با توجه به نیازمندی‌های پروژه سمافورها(و سایر متغیرهای به‌هنگام‌سازی) باید ریسه‌های با اولویت بالاتر را بر ریسه‌های با اولویت پایین‌تر ترجیح دهند. با این حال پیاده‌سازی ریسه‌های با اولویت بالاتر را براساس اولویت مبنا `Base Priority` به جای اولویت موثر ‍`Effective Priority` انتخاب می‌کند. اساسا اهدای اولویت زمانی که سمافور تصمیم می‌گیرد که کدام ریسه رفع مسدودیت شود، تاثیر داده نمی‌شود. تستی طراحی کنید که وجود این باگ را اثبات کند. تست‌های `Pintos` شامل کد معمولی در سطح هسته (مانند متغیرها، فراخوانی توابع، جملات شرطی و ...) هستند و می‌توانند متن چاپ کنند و می‌توانیم متن چاپ شده را با خروجی مورد انتظار مقایسه کنیم و اگر متفاوت بودند، وجود مشکل در پیاده‌سازی اثبات می‌شود. شما باید توضیحی درباره این که تست چگونه کار می‌کند، خروجی مورد انتظار و خروجی واقعی آن فراهم کنید.

```
Priority(Ti)=i
T0 -> Create(T1) Yield() Create(T2) Yield() Create(T4) Yield() Create(T3) sema_up(S0)
T1 -> Acquire(Lock1) sema_down(S0) Release(Lock1)
T2 -> Acquire(Lock2) Acquire(Lock1) Release(Lock2)
T4 -> Acquire(Lock2) Print("T4")
T3 -> Acquire(Lock1) Print("T3")
```
قبل از این که در ریسهٔ T1، دستور `sema_up(S0)` صدا زده‌شود، T2 منتظر Lock1، و T4 منتظر Lock2، و T3 منتظر Lock1 است. بعد از اینکه S0 برابر ۱ شد، T1 اجرا می‌شود و Lock1 را آزاد می‌کند. زمانی که `sema_up(S0)‍‍`  اجرا می‌شود، T1، قفل Lock1 را آزاد می‌کند. در این زمان، اگر اهدای اولویت صورت پذیرد، باید T2 با اولویت مؤثر ۴ که بخاطر T4 است، قفل را بگیرد، اما اگر بر اساس اولویت پایه پیش برود، T3 قفل را می‌گیرد. در این صورت، خروجی درست
```
T4
T3
```
است، اما به اشتباه
```
T3
T4
```
چاپ می‌شود.
