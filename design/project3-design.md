تمرین گروهی ۳ - مستند طراحی
======================

گروه 7
-----

>>‫نام و آدرس پست الکترونیکی اعضای گروه را در این قسمت بنویسید.

محمدسپهر پورقناد sepehrpourghannad@yahoo.com
سیدمحمدصادق کشاورزی mohammadsadeghkeshavarzi@yahoo.com
فرزام زهدی‌نسب farzamzohdi@gmail.com
مصطفی اوجاقی m.ojaghy@gmail.com
 
مقدمات
----------

>>‫ ‫‫اگر نکات اضافه‌ای در مورد تمرین یا برای دستیاران آموزشی دارید در این قسمت  ‫بنویسید.

>>‫ لطفا در این قسمت تمامی منابعی (غیر از مستندات Pintos، اسلاید‌ها و دیگر منابع‫ ‫درس) را که برای تمرین از آن‌ها استفاده کرده‌اید در این قسمت بنویسید.

بافر کش
============

داده‌ساختار‌ها و توابع
---------------------

>>‫ در این قسمت تعریف هر یک از `struct` ها، اعضای `struct` ها، متغیرهای سراسری یا ایستا، `typedef` ها یا `enum` هایی که ایجاد کرده‌اید یا تغییر داده‌اید را‫ بنویسید و دلیل هر کدام را در حداکثر ۲۵ کلمه توضیح دهید.
```
list cache;
hash cache_hash;
lock cache_lock;

struct cache_block {
	lock lock;
	list_elem l_elem;
	hash_elem h_elem;
	uint8_t data[BLOCK_SECTOR_SIZE];
	bool dirty;
	block_sector_t sector;
	int access_count;
}

void cache_init ();
void* read_from_cache ();
int write_to_cache ();
```

`cache` : لیستی است که در آن بلوک‌های کش نگه داری می‌کند.
`cache_hash`: هش مپی است که برای دسترسی در زمان ثابت به اعضای کش بکار می‌برد.
`cache_lock`: قفلی است که هنگام دسترسی به `cache` و `cache_hash` بکار می‌رود.

`lock`:برای هنگام سازی یک بلوک کش بکار می‌رود.
`h_elem`: برای درج در هش مپ بکار می‌رود.
`l_elem`: برای درج در لیست کش بکار می‌رود.
`data`: داده‌ی مذکور.
`dirty`: نشانگر اینکه آیا داده‌ی موجود در بلاک کش مذکور باید در دیسک نوشته شود یا خیر.
`sector`: شماره‌ی سکتور مربوطه در دیسک.
`access_count`: تعداد ریسه‌هایی که در حال حاضر در حال استفاده از بلوک کش هستند.

الگوریتم‌ها
------------

>>‫ توضیح دهید که الگوریتم مورد استفاده‌ی شما به چه صورت یک بلاک را برای جایگزین ‫ شدن انتخاب می‌کند؟
ما از الگوریتم lru استفاده می‌کنیم. یک لیست مرتب بر اساس آخرین زمان دسترسی نگه می‌داریم. به گونه‌ای که ابتدای لیست اخرین بلوکی بوده است که به آن دسترسی صورت گرفته است.
در صورتی هم که بلوک در کش موجود نبود و باید به آن اضافه می‌شد، عضو آخر لیست را حذف می‌کنیم.

>>‫ روش پیاده‌سازی `read-ahead` را توضیح دهید.
یک متغیر ثابت مانند `READ_AHEAD_AMOUNT` تعریف می‌کنیم که هر زمان که دسترسی به دیسک صورت گرفت، به این اندازه از سکتور خواسته‌شده فعلی جلوتر رفته و مقادیر مربوطه در کش لود کند.

همگام سازی
-------------

>>‫ هنگامی که یک پردازه به طور مستمر در حال خواندن یا نوشتن داده در یک بلاک بافرکش‫ می‌باشد به چه صورت از دخالت سایر پردازه‌ها جلوگیری میشود؟
برای هر بلاک یک قفل در نظر گرفتیم که هر ریسه هنگام دسترسی به بلک مربوطه آن را در اختیار می‌گیرد. 

>>‫ در حین خارج شدن یک بلوک از حافظه‌ی نهان، چگونه از پروسه‌های دیگر جلوگیری می‌شود تا‫ به این بلاک دسترسی پیدا نکنند؟
همانطور که در بالا گفته شد برای دسترسی به بلاک، نیاز است تا قفل آن در اختیار گرفته شود. پس اگر ریسه‌ای بخواهد بلاکی را خارج کند که توسط ریسه‌های دیگر در حال خوانده شدن است، می‌بایست منتظر آن ریسه‌ها بماند تا قفل را آزاد کنند.
در هر مرحله از خواندن از یک بلوک، با توجه به این که ممکن است ریسه قبلی به طور کلی این بلوک را از کش خارج کرده باشد، برای صحت داده‌ای که می‌خوانیم، ابتدا باید `sector` بلوک مذکور را با `sector` مطلوب مقایسه شود و در صورت مغایرت باید دوباره از دیسک خوانده شود.

منطق طراحی
-----------------

>>‫ یک سناریو را توضیح دهید که از بافر کش، `read-ahead` و یا از `write-behind` استفاده کند.
مثلا فرض کنید که در حال خواند فایلی هستیم که ۱ کیلو بایت حجم دارد و کاربر قصد دارد تا میانه فایل را بخواند، و بعد‌ها دوباره ادامه فایل را بخواند. در اینصورت می‌توانیم کل فایل را به صورت یکجا از دیسک خوانده و در دو بلوک از کش قرار دهیم و بعدا که ادامه فایل درخواست شد از کش خوانده خواهد شد.


فایل‌های قابل گسترش
=====================

داده‌ساختار‌ها و توابع
---------------------

>>‫ در این قسمت تعریف هر یک از `struct` ها، اعضای `struct` ها، متغیرهای سراسری‫ یا ایستا، `typedef` ها یا `enum` هایی که ایجاد کرده‌اید یا تغییر داده‌اید را بنویسید و‫ دلیل هر کدام را در حداکثر ۲۵ کلمه توضیح دهید.

```
struct inode_disk {
	off_t length;
	unsigned magic;
	block_sector_t direct[124];
	block_sector_t indirect;
	block_sector_t doubly_indirect;
};

struct inode {
	...
	struct lock lock;
	...
}

```

`direct`: آرایه‌ای از شماره سکتور‌هایی که داده در آن قرار دارد.
`indirect`: اشاره گر به سکتوری که در آن آرایه ای از شماره سکتور‌های ادامه داده قرار دارد.
`doubly_indirect`: همانند بالایی، با این تفاوت که هر عضو آن خود یک `indirect` است.

>>‫ بیشترین سایز فایل پشتیبانی شده توسط ساختار inode شما چقدر است؟
124×512+512×512+512×512×512 = 134543360 = 130Mbyte

همگام سازی
----------

>>‫ توضیح دهید که اگر دو پردازه بخواهند یک فایل را به طور همزمان گسترش دهند، کد شما چگونه از‫ حالت مسابقه جلوگیری می‌کند.
هنگامی دو پردازه می‌‌خواهند با یک فایل کار کنند، کافی است  هنگامی که می‌خواهنند فایل را گسترش دهند می‌بایست قفلی که در inode تعبیه شده را در اختیار بگیرند.

>>‫ فرض کنید دو پردازه‌ی A و B فایل F را باز کرده‌اند و هر دو به end-of-file اشاره کرده‌اند.‫ اگر  همزمان A از F بخواند و B روی آن بنویسد، ممکن است که A تمام، بخشی یا هیچ چیز از‫ اطلاعات نوشته شده توسط B را بخواند. همچنین A نمی‌تواند چیزی جز اطلاعات نوشته شده توسط B را‫ بخواند. مثلا اگر B تماما ۱ بنویسد، A نیز باید تماما ۱ بخواند. توضیح دهید کد شما چگونه از‫ این حالت مسابقه جلوگیری می‌کند.
به طور کلی هرگاه عملیاتی مانند خواندن/نوشتن بروی `inode` خواست انجام بگیرد ، می‌بایست قفل مربوط به `inode` مذکور گرفته شود.

>>‫ توضیح دهید همگام سازی شما چگونه "عدالت" را برقرار می‌کند. فایل سیستمی "عادل" است که‫ خواننده‌های اطلاعات به صورت ناسازگار نویسنده‌های اطلاعات را مسدود نکنند و برعکس. بدین ترتیب‫ اگر تعدادی بسیار زیاد پردازه‌هایی که از یک فایل می‌خوانند نمی‌توانند تا ابد مانع نوشده شدن‫ اطلاعات توسط یک پردازه‌ی دیگر شوند و برعکس.
با توجه به اینکه ریسه‌ها به ترتیب در لیست سمافور درج می‌شوند پس همیشه نوبت آنها خواهد رسید تا عملیات خواندن/نوشتن خود را انجام دهند. 

منطق طراحی
----------

>>‫ آیا ساختار `inode` شما از طبقه‌بندی چند سطحه پشتیبانی می‌کند؟ اگر بله، دلیل خود را برای‫ انتخاب این ترکیب خاص از بلوک‌های مستقیم، غیر مستقیم و غیر مستقیم دوطرفه توضیح دهید.‌‫ اگر خیر، دلیل خود برای انتخاب ساختاری غیر از طبقه‌بندی چند سطحه و مزایا و معایب ساختار‫ مورد استفاده خود نسبت به طبقه‌بندی چند سطحه را توضیح دهید.
بله - چون که برای فایل های کوچکتر سربار آن کمتر است، و برای در عین حال از فایل‌های با اندازه بزرگ نیز پشتیبانی ‌می‌کند. علاوه براین محدودیت متوالی نوشتن در سکتور‌ها را، که به صورت پیشفرض پیاده‌سازی شده است، از بین می‌برد و کمتر با مشکل فرگمنتیشن روبرو خواهیم شد.


زیرمسیرها
============

داده‌ساختار‌ها و توابع
---------------------

>>‫ در این قسمت تعریف هر یک از `struct` ها، اعضای `struct` ها، متغیرهای سراسری‫ یا ایستا، `typedef` ها یا `enum` هایی که ایجاد کرده‌اید یا تغییر داده‌اید را بنویسید و‫ دلیل هر کدام را در حداکثر ۲۵ کلمه توضیح دهید.

```
struct thread {
	...
	struct dir *cwd;
	...	
}

struct inode_disk {
	...
	block_sector_t parent_dir;
	...
}

struct dir_entry {
	...
	bool is_dir;
}
```

`cwd`: مسیر پوشه فعلی ریسه.
`parent_dir`: اشاره گر به `inode_disk` پوشه پدر.
`is_dir`: نشان می‌دهد که  مدخل مربوطه یک پوشه، پوشه است یا خیر.

الگوریتم‌ها
-----------
>>‫ کد خود را برای طی کردن یک مسیر گرفته‌شده از کاربر را توضیح دهید.‫ آیا عبور از مسیرهای absolute و relative تفاوتی دارد؟
در ابتدا توجه کنید که برای مسیریابی مطلق از ریشه شروع می‌کنیم. برای مسیریابی نسبی نیز از `cwd` استفاده می‌کنیم.
برای حرکت روبه داخل برای پوشه ها، از تابع `dir_lookup` استفاده می‌کنیم تا متوجه شویم که آیا پوشه‌ی فعلی موجود است یا خیر. در صورتی که موجود بود، یا `dir_open` ، پوشه جدید را بدست می‌اوردیم و `cwd` را متناسبا عوض می‌کنیم. در صورتی هم که بخواهیم احیانا به پوشه‌(های) پدر برویم، ابتدا از طریق `cwd` ، به ‍`inode` دسترسی پیدا می‌کنیم. سپس به `inode_disk` مربوطه و از آن طریق به  `block_sector_t parent_dir` می‌رسیم که همان محل ذخیره پوشه پدر در دیسک است. در نهایت هم با استفاده از `inode_open`  به `inode` پدر است. و می‌توانیم عملیات دلخواه خود را روی آن انجام دهیم.


همگام سازی
-------------

>>‫ چگونه از رخ دادن race-condition در مورد دایرکتوری ها پیشگیری می‌کنید؟‫ برای مثال اگر دو درخواست موازی برای حذف یک فایل وجود داشته باشد و ‫ تنها یکی از آنها باید موفق شود یا مثلاً دو ریسه موازی بخواهند فایلی‫ یک اسم در یک مسیر ایجاد کنند و مانند آن.‫ آیا پیاده سازی شما اجازه می‌دهد مسیری که CWD یک ریسه شده یا پردازه‌ای‫ از آن استفاده می‌کند حذف شود؟ اگر بله، عملیات فایل سیستم بعدی روی آن‫ دایرکتوری چه نتیجه‌ای می‌دهند؟ اگر نه، چطور جلوی آن را می‌گیرید؟
در ابتدا توجه کنید که هیچ پوشه ناتهی را حذف نمی‌کنیم.. همچنین هر  `inode` را مادامی که توسط ریسه‌ای باز است حذف نمی‌کنیم(`open_cnt > 0`). بدیهی است که فایل اجرایی هر ریسه و  `cwd` یک ریسه، باز محسوب می‌شوند. 
برای جلوگیری از شرایط مسابقه، با توجه به اینکه هر پوشه به یک `inode` مربوط است، پس هر عملیاتی که روی آن انجام می‌گیرد می‌تواند بوسیله قفلی که در آن تعبیه شده است، همگام سازی شود.

منطق طراحی
-----------------
>>‫ توضیح دهید چرا تصمیم گرفتید CWD یک پردازه را به شکلی که طراحی کرده‌اید‫ پیاده‌سازی کنید؟
برای اینکه بسیاری از فراخوانی های سیستمی روی `inode` صورت می‌گیرد و کار را راحتتر می‌کند. در عین حال انعطاف‌پذیری برای انجام آدرس ‌دهی های نسبی را نیز ایجاد می‌کند.
