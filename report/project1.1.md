تمرین گروهی ۱/۱ برنامه‌های کاربر
======================

شماره گروه: 7
-----

محمدسپهر پورقناد sepehrpourghannad@yahoo.com

سید محمدصادق کشاورزی mohammadsadeghkeshavarzi@yahoo.com

فرزام زهدی نسب farzamzohdi@gmail.com

مصطفی اوجاقی m.ojaghy@gmail.com

# تغییرات پیاده‌سازی نسبت به سند طراحی

--------
ماموریت اول بدون چالش خاصی مطابق با سند طراحی پیاده‌سازی شد.

فراخوانی‌های سیستمی

================

داده‌ساختار‌ها

----------------
داده‌ساختارها به صورت بازطراحی:
```
struct thread
	{
	   ...
	   struct list children;
	   struct thread_info *thread_info;

	   struct file* bin_file;
		struct list files;
		int fd_count;
	   ...
	}

```

لیست قفل‌های در اختیار ریسه حذف شد و سمافور مربوط به ریسه  و `exit_code` آن به داده‌ساختار `thread_info` اضافه شدند. داده‌ساختار `thread_info` شامل بخشی از اطلاعات ریسه است که مورد نیاز پدر است و هر ریسه در لیست فرزندانش به این اطلاعات اشاره‌گر مناسب دارد.

```
struct thread_info
   {
      struct list_elem elem;
      struct semaphore sema;
      tid_t tid;
      bool exited;
      *bool orphaned;
      int exit_code;
      *enum exit_state state;
      struct semaphore load_sema;
   };
```

`sema` سمافور مربوط به ریسه می‌باشد که پدر به کمک آن منتظر پایان کار ریسه فرزند می‌شود.
`tid` در واقع شناسه ریسه است که موقع ایجاد ریسه توسط هسته اعلام می‌شود.
`exited` نشان می‌دهد که کار ریسه به اتمام رسیده است یا نه.
`orphaned` نشان می‌دهد که ریسه‌ی پدر به اتمام رسیده یا نه.
`exit_code`  نشان دهنده شناسه خروج ریسه می‌باشد.
`state` نشان دهنده وضعیت خروجی ریسه است.
`load_sema` که برای اطمینان از بارگیری فایل اجرایی ریسه استفاده می‌شود.

الگوریتم‌ها

------------

برای چک کردن صحت اشاره‌گرهای فرا‌خوانی‌های سیستمی توابع زیر را در `syscall.c`  پیاده‌سازی کردیم :
```
static bool is_valid_byte_addr(void *addr);
static bool is_valid_addr(void *addr, size_t size);
static bool is_valid_str(char *str);
```

تابع اول به جهت بررسی صحت آدرس داده شده تا اندازه ۱ بایت است به این صورت که ابتدا پوچ بودن اشاره‌گر و سپس مربوط بودن آدرس به فضای آدرسی کاربر را بررسی می‌کنیم و نهایتا بررسی می‌کنیم که این آدرس در صفحه ریسه معتبر باشد. تابع دوم به کمک بررسی اولین و آخرین بایت مربوط به آدرس و اندازه داده شده با کمک تابع اول، صحیح بودن اشاره‌گر با اندازه داده شده را بررسی می‌کند. تابع سوم هم جهت بررسی صحت آدرس رشته داده‌ شده است که ابتدا معتبر بودن آدرس شروع را بررسی می‌کند و سپس با خواندن رشته به کمک آدرس مجازی آن در هسته اعتبار کل رشته را بررسی می‌کند.

> هر دستیابی هسته به حافظه‌ی برنامه‌ی کاربر، که آدرس آن را کاربر مشخص کرده است، ممکن است به دلیل مقدار نامعتبر اشاره‌گر منجر به شکست شود. در این صورت باید پردازه‌ی کاربر خاتمه داده شود. فراخوانی های سیستمی پر از چنین دستیابی‌هایی هستند. برای مثال فراخوانی سیستمی `write‍` نیاز دارد ابتدا شماره‌ی فراخوانی سیستمی را از پشته‌ی کاربر بخواند، سپس باید سه آرگومان ورودی و بعد از آن مقدار دلخواهی از حافظه کاربر را (که آرگومان ها به آن اشاره می کنند) بخواند. هر یک از این دسترسی ها به حافظه ممکن است با شکست مواجه شود. بدین ترتیب با یک مسئله‌ی طراحی و رسیدگی به خطا (error handling) مواجهیم. بهترین روشی که به ذهن شما می‌رسد تا از گم‌شدن مفهوم اصلی کد در بین شروط رسیدگی به خطا جلوگیری کند چیست؟ همچنین چگونه بعد از تشخیص خطا، از آزاد شدن تمامی منابع موقتی‌ای که تخصیص داده‌اید (قفل‌ها، بافر‌ها و...) مطمئن می‌شوید؟ در تعداد کمی پاراگراف، استراتژی خود را برای مدیریت این مسائل با ذکر مثال بیان کنید.
با توجه به اینکه اطلاعات مورد نیاز هر ریسه از طریق داده‌ساختار `thread` قابل دسترسی است قبل از اتمام ریسه تمامی اطلاعات آن که در صفحه ریسه نیستند آزاد می‌کنیم و سپس صفحه ریسه را می‌بندیم. نظر به اینکه اطلاعات مورد‌ نیاز ریسه پدر از فرزندان ( `thread_info`)  توسط پدر و به هنگام تولد فرزند `malloc`می‌شوند، درصورتی که اجرای ریسه فرزند زودتر تمام شود، پدرش اطلاعات مربوطه را هنگام اتمام آزاد می‌کند و در صورتی که اجرای ریسه پدر زودتر تمام بشود، مقدار `orphaned` در فرزندش را `true`می‌کند تا فرزند خود به هنگام اتمامش اطلاعات را آزاد کند.

همگام‌سازی

---------------
> فراخوانی سیستمی `exec` نباید قبل از پایان بارگذاری فایل اجرایی برگردد، چون در صورتی که بارگذاری فایل اجرایی با خطا مواجه شود باید `-۱` برگرداند. کد شما چگونه از این موضوع اطمینان حاصل می‌کند؟ چگونه وضعیت موفقیت یا شکست در اجرا به ریسه‌ای که `exec` را فراخوانی کرده اطلاع داده می‌شود؟
در صورتی که فایل اجرایی موجود بوده و پردازه به درستی ایجاد شد با یک `sema_down` منتظر سمافور `load_sema` می‌مانیم و با استفاده از اطلاعات `status` تشخیص می‌دهیم که ریسه به درستی آغاز به کار کرده یا نه و پس از بارگیری کامل فایل اجرایی هم روی سمافور مربوطه `sema_up` صدا زده می‌شود.

# وظایف افراد و تقسیم کار

------
در ابتدای پیاده‌سازی تمرین در قالب یک جلسه مجازی به صورت چهارنفره به طوری که یک نفر صفحه‌‌اش را با دیگران به اشتراک گذاشته و کد‌ها را نمایش داده و می‌نویسد و هر چهار نفر با مشورت هم تمرین‌ را جلو می‌برند، مطابق پیشنهادات سند تمرین با پیاده‌سازی فراخوانی سیستمی `write` برای `file descriptor` خروجی استاندارد (`STDOUT`) شروع کردیم و پس از روشن و مشخص‌تر شدن کار‌ها به دو گروه دو نفری تقسیم شدیم، گروه اول (محمدسپهر پورقناد و مصطفی اوجاقی) به سراغ انجام ماموریت اول (پاس‌دادن آرگومان) و گروه دوم (فرزام زهدی‌نسب و سید محمدصادق کشاورزی) به سراغ انجام ماموریت دوم (فراخوانی های سیستمی برای کنترل پردازه‌ها) رفتند. گروه اول پس از اتمام ماموریت اول به جهت اتمام ماموریت دوم به گروه دوم ملحق شدند در این زمان گروه دوم بحث راستی‌آزمایی اشاره‌گر‌های پاس داده‌شده به فراخوانی‌های سیستمی را به انجام رسانده بودند و فرا‌خوانی‌های `halt` و  `practice` را پیاده‌سازی کرده‌ بود. در ماموریت دوم برای اجرای سایر فراخوانی‌های سیستم تغییراتی نسبت به سند طراحی ایجاد کردیم (برای مثال در داده‌ساختار `thread`) و عمده زمان را مشغول رفع ایرادات و تلاش برای پاس کردن آزمون‌های بیش‌تر بودیم. پس از اتمام این ماموریت باز در همان قالب چهارنفری به سراغ ماموریت سوم رفتیم. در این بخش با چالش کم‌تری روبه‌رو بودیم. پس از پیاده‌سازی این بخش مشغول رفع ایرادات باقی‌مانده و پاس کردن تست‌های باقی‌مانده شدیم و پس از آن هم به نوشتن این سند پرداختیم.
